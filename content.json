{"meta":{"title":"KANG ARCHIVE","subtitle":null,"description":"강래현 전용 저장소","author":"R.H.Kang","url":"https://rhkang.github.io"},"pages":[{"title":"About","date":"2018-05-10T04:45:36.000Z","updated":"2019-04-08T07:07:33.425Z","comments":true,"path":"about/index.html","permalink":"https://rhkang.github.io/about/index.html","excerpt":"","text":"Information Contact Address Phone No. (+82)1029085919 E-mail rhkang@kaist.ac.kr Facebook facebook.com/krh0314"}],"posts":[{"title":"C++ Data 다루기","slug":"programming-with-cpp","date":"2019-05-15T02:06:17.000Z","updated":"2019-05-16T05:34:44.475Z","comments":true,"path":"2019/05/15/programming-with-cpp/","link":"","permalink":"https://rhkang.github.io/2019/05/15/programming-with-cpp/","excerpt":"","text":"Struct1234567891011121314#include &lt;bits/stdc++.h&gt;using namespace std;struct obj&#123; int mem1; char[3] mem2;&#125;;int main()&#123; struct obj obj1 = &#123;2, &#123;'a', 'b', '+'&#125;&#125;; cout &lt;&lt; sizeof(obj1) &lt;&lt; endl; return 0;&#125;","categories":[{"name":"IT","slug":"IT","permalink":"https://rhkang.github.io/categories/IT/"},{"name":"C/C++","slug":"IT/C-C","permalink":"https://rhkang.github.io/categories/IT/C-C/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://rhkang.github.io/tags/C/"}]},{"title":"IA32 Programming","slug":"IA32-programming","date":"2019-04-11T06:09:00.000Z","updated":"2019-04-11T10:25:24.902Z","comments":true,"path":"2019/04/11/IA32-programming/","link":"","permalink":"https://rhkang.github.io/2019/04/11/IA32-programming/","excerpt":"","text":"Compiler Explorer - https://godbolt.org/ (C코드를 Assembly로 변환) Indexed Addressing Modes$D(R_b, R_i, S) = \\textrm{Mem}[\\textrm{Reg}[R_b] + S* \\textrm{Reg}[R_i] + D]$ $D$: Constant “displacement” 1, 2, or 4 bytes$R_b$: Base Register$R_i$: Index Register - except for %esp$S$: Scale - 1, 2, 4, or 8 Operations movl Source, DestMove 4-byte (“long”) word Source Destination Assembly C analog Imm Reg movl $0x4, %eax temp = 0x4; Imm Mem movl $-147, (%eax) *p = -147; Reg Reg movl %eax, %edx temp2 = temp1; Reg Mem movl %eax, (%edx) *p = temp; Mem Reg movl (%eax), %edx temp = *p; Arithmetic Operations Format Computation addl Src, Dest Dest = Dest + Src subl Src, Dest Dest = Dest - Src imull Src, Dest Dest = Dest * Src sall Src, Dest Dest = Dest &lt;&lt; Src (Also called shll) sarl Src, Dest Dest = Dest &gt;&gt; Src (Arithmetic) shrl Src, Dest Dest = Dest &gt;&gt; Src (Logical) xorl Src, Dest Dest = Dest ^ Src andl Src, Dest Dest = Dest &amp; Src orl Src, Dest Dest = Dest $\\vert$ Src incl Dest Dest = Dest + 1 decl Dest Dest = Dest - 1 negl Dest Dest = -Dest notl Dest Dest = ~Dest pushl Src Fetch operand at Src Decrement %esp by 4 Write operand at address given by %esp popl Dest Read operand at address given by %esp increment %esp by 4 Write to Dest call label Push return address on Stack (return address = current %eip) Jump to label (Change %eip to label; %eip is program counter) ret Pop address from stack (Dest = %eip) Jump to address Stack FrameCurrent Stack Frame Parameters for function about to call Local variables Saved register context Old frame Pointer Caller Stack Frame Retrun Address (pushed by call instruction) Arguments for this call Code Examplesclass06_cs230s19 - #51234int sum(int x, int y)&#123; int t = x + y; return t;&#125; 12345678_sum: pushl %ebp movl %esp, %ebp movl 12%(ebp), %eax addl 8(%ebp), %eax movl %ebp, %esp popl %ebp ret class06_cs230s19 - #15123456void swap(int *xp, int *yp)&#123; int t0 = *xp; int t1 = *yp; *xp = t1; *yp = t0;&#125; 12345678910111213141516swap: pushl %ebp movl %esp, %ebp pushl %ebx movl 12%(ebp), %ecx movl 8(%ebp), %edx movl (%ecx), %eax movl (%edx), %ebx movl %eax, (%edx) movl %ebx, (%ecx) movl -4(%ebp), %ebx movl %ebp, %esp popl %ebp ret","categories":[{"name":"IT","slug":"IT","permalink":"https://rhkang.github.io/categories/IT/"},{"name":"System","slug":"IT/System","permalink":"https://rhkang.github.io/categories/IT/System/"}],"tags":[{"name":"SP","slug":"SP","permalink":"https://rhkang.github.io/tags/SP/"}]},{"title":"General-Purpose Registers (범용 레지스터)","slug":"general-purpose-registers","date":"2019-04-08T11:48:46.000Z","updated":"2019-04-11T07:36:37.648Z","comments":true,"path":"2019/04/08/general-purpose-registers/","link":"","permalink":"https://rhkang.github.io/2019/04/08/general-purpose-registers/","excerpt":"","text":"레지스터(Register)란? - https://en.wikipedia.org/wiki/Processor_registerx86 레지스터 - https://en.wikipedia.org/wiki/X86#x86_registers EAX (Extended Accumulator Register) EBX (Extended Base Register) ECX (Extended Counter Register) EDX (Extended Data Register) ESI (Extended Source Index) EDI (Extended Destination Index) ESP (Extended Stack Pointer) EBP (Extended Base Pointer) Caller (콜러) : Caller saves temporary in its frame before callingCallee (콜리) : Callee saves temporary in its frame before using 범용 레지스터들은 Caller-save 혹은 Callee-save 여부를 통해 구분이 가능하다. EAX, EDX, ECX는 Caller-save,EBX, ESI, EDI는 Callee-save로서 관리된다.ESP, EBP는 각각 Stack Pointer, Frame Pointer로서의 특별한 역할을 지닌다.EAX는 함수의 Return 값을 저장하기도 한다.","categories":[{"name":"IT","slug":"IT","permalink":"https://rhkang.github.io/categories/IT/"},{"name":"System","slug":"IT/System","permalink":"https://rhkang.github.io/categories/IT/System/"}],"tags":[{"name":"SP","slug":"SP","permalink":"https://rhkang.github.io/tags/SP/"}]},{"title":"Java 이모저모","slug":"about-java","date":"2019-03-04T06:23:52.000Z","updated":"2019-03-04T07:07:28.659Z","comments":true,"path":"2019/03/04/about-java/","link":"","permalink":"https://rhkang.github.io/2019/03/04/about-java/","excerpt":"","text":"Reference1234567String s1 = new String(\"cat\");String s2 = new String(\"cat\");// those are differentString s3 = \"cat\";String s4 = \"cat\";// they refer the same object Compare Two Strings12s == t; //it compares addresses of thems.equals(t); //it compares character sequences","categories":[{"name":"IT","slug":"IT","permalink":"https://rhkang.github.io/categories/IT/"},{"name":"Java","slug":"IT/Java","permalink":"https://rhkang.github.io/categories/IT/Java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://rhkang.github.io/tags/java/"}]},{"title":"C언어 이모저모","slug":"about-c","date":"2019-03-03T10:15:10.000Z","updated":"2019-05-15T02:25:36.743Z","comments":true,"path":"2019/03/03/about-c/","link":"","permalink":"https://rhkang.github.io/2019/03/03/about-c/","excerpt":"","text":"How do you allow spaces to be entered using scanf?https://stackoverflow.com/questions/1247989/how-do-you-allow-spaces-to-be-entered-using-scanf What int argC, char *argV[] mean?https://stackoverflow.com/questions/3024197/what-does-int-argc-char-argv-mean Ternary Operator12345678if (x&gt;0) y = 1;else y = -1;// is equivalent toy = (x&gt;0) ? 1: -1; 올림, 내림, 반올림123456#include &lt;math.h&gt;// #include &lt;cmath&gt; &lt;- c++result = ceil(4.2) // result = 5.0result = floor(4.2) // result = 4.0result = floor(4.5 + 0.5) // result = 5.0 (반올림 시 안에 0.5더해주고 내리기)","categories":[{"name":"IT","slug":"IT","permalink":"https://rhkang.github.io/categories/IT/"},{"name":"C/C++","slug":"IT/C-C","permalink":"https://rhkang.github.io/categories/IT/C-C/"}],"tags":[{"name":"C","slug":"C","permalink":"https://rhkang.github.io/tags/C/"}]},{"title":"Latex Guide","slug":"latex-guide","date":"2018-05-12T00:04:43.000Z","updated":"2019-04-13T05:53:09.707Z","comments":true,"path":"2018/05/12/latex-guide/","link":"","permalink":"https://rhkang.github.io/2018/05/12/latex-guide/","excerpt":"","text":"수식 기호가 나타나지 않을 경우 페이지 우측 상단에서 안전하지 않은 스크립트 로드.Code 사용의 경우 따로 정의한 code.tex 파일이 필요함. Template 123456789101112131415161718192021222324252627282930313233343536373839404142434445\\documentclass[12pt,fleqn]&#123;article&#125;\\usepackage&#123;kotex&#125; % 한글 사용\\usepackage&#123;setspace&#125;\\usepackage&#123;fullpage&#125;\\usepackage&#123;amssymb&#125;\\usepackage&#123;amsmath&#125;\\usepackage&#123;mathtools&#125;\\usepackage[ruled, linesnumbered]&#123;algorithm2e&#125;\\usepackage&#123;graphicx&#125;\\usepackage&#123;subcaption&#125;\\usepackage&#123;hyperref&#125;\\hypersetup&#123; colorlinks=true, linkcolor=blue, filecolor=blue, urlcolor=blue,&#125;\\def\\title&#123;\\textbf&#123;TITLE HERE&#125;&#125;\\def\\author&#123;NAME HERE&#125;\\def\\date&#123;MAY 2018&#125;\\input&#123;code&#125;\\input&#123;macros&#125;\\begin&#123;document&#125;\\setstretch&#123;1.2&#125;\\fbox&#123; \\parbox&#123;0.9\\textwidth&#125;&#123; \\textbf&#123;MC322: Discrete Mathematics&#125; \\begin&#123;center&#125; \\LARGE&#123;\\title&#125; \\end&#123;center&#125; \\author \\hfill \\date &#125;&#125;\\section&#123;&#125;\\end&#123;document&#125; Code 사용 123\\begin&#123;code&#125; % Contents...\\end&#123;code&#125; Symbols Symbols Syntax $\\mathcal{C}, \\mathcal{R}, \\mathcal{Q}, …$ \\mathcal{} $\\mathbf{R}, \\mathbf{N}, \\mathbf{P}, …$ \\mathbf{} $\\mathbb{N}, \\mathbb{R}, \\mathbb{Q}, …$ \\mathbb{} $\\phi, \\varphi, \\psi, \\sigma, \\aleph, \\pi, \\mu, …$ \\phi, \\varphi, \\psi, \\sigma, \\aleph, \\pi, \\mu, … $\\vdash, =, \\geq, \\leq, …$ \\vdash, =, \\geq, \\leq, … $\\neq, \\nvdash, …$ \\neq, \\nvdash, … $\\nleq, \\nleqslant, \\nleqq, \\lneq, \\lneqq, \\lvertneqq, \\lnsim, \\lnapprox, …$ \\nleq, \\nleqslant, \\nleqq, \\lneq, \\lneqq, \\lvertneqq, \\lnsim, \\lnapprox, … $\\leftarrow, \\rightarrow, \\uparrow, \\downarrow, \\Leftarrow, \\Rightarrow, \\Leftrightarrow$ \\leftarrow, \\rightarrow, \\uparrow, \\downarrow, \\Leftarrow, \\Rightarrow, \\Leftrightarrow ${\\displaystyle \\sum_{i\\in I}{\\textrm{something}}}$ {\\displaystyle \\sum_{i\\in I}{\\textrm{something}}} $\\oplus, \\odot, \\otimes, \\uplus, \\cup, \\cap$ \\oplus, \\odot, \\otimes, \\uplus, \\cup, \\cap $\\bigoplus, \\bigodot, \\bigotimes, \\biguplus, \\prod, \\sum$ \\bigoplus, \\bigodot, \\bigotimes, \\biguplus, \\prod, \\sum $\\bigcup, \\bigcap, \\int, \\oint, \\bigvee, \\bigwedge$ \\bigcup, \\bigcap, \\int, \\oint, \\bigvee, \\bigwedge $\\lfloor \\; \\rfloor \\; \\lceil \\; \\rceil \\; \\langle \\; \\rangle$ \\lfloor \\rfloor \\lceil \\rceil \\langle \\rangle $\\hat{a}, \\acute{a}, \\bar{a}, \\dot{a}, \\vec{a}, \\ddot{a}, \\tilde{a}$ \\hat{a}, \\acute{a}, \\bar{a}, \\dot{a}, \\vec{a}, \\ddot{a}, \\tilde{a} $\\overline{abc}, \\overrightarrow{pq}, \\frac{a}{b}$ \\overline{abc}, \\overrightarrow{pq}, \\frac{a}{b} $\\blacksquare \\; \\therefore \\; \\because \\; \\bot$ \\blacksquare \\; \\therefore \\; \\because \\; \\bot","categories":[{"name":"IT","slug":"IT","permalink":"https://rhkang.github.io/categories/IT/"}],"tags":[{"name":"Latex","slug":"Latex","permalink":"https://rhkang.github.io/tags/Latex/"}]},{"title":"범용 알고리즘 정리","slug":"basic-algorithms","date":"2018-05-11T11:47:33.000Z","updated":"2019-03-06T04:13:10.102Z","comments":true,"path":"2018/05/11/basic-algorithms/","link":"","permalink":"https://rhkang.github.io/2018/05/11/basic-algorithms/","excerpt":"","text":"Latest Update: 2018.05.11 Stack Python123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051class Node(object): def __init__(self, data): self.d = data self.prev = Noneclass Stack(object): def __init__(self): self._t = None self._l = 0 def push(self, n): # n: Node Object if self._l == 0: n.prev = None else: n.prev = self._t self._t = n self._l += 1 def pop(self): if self._l == 0: return None else: tail = self._t self._t = self._t.prev self._l -= 1 return tail def length(self): print (self._l)if __name__ == \"__main__\": import random stack = Stack() for i in range(10): num = random.randint(0, 9) + 1 print (num, end=' ') n = Node(num) stack.push(n) print (\"length: \", stack.length()) for i in range(10): print (i+1, \":\", stack.pop().d) Queue Python12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455class Node(object): def __init__(self, data): self.d = data self.next = None class Queue(object): def __init__(self): self._h = None self._t = None self._l = 0 def enqueue(self, n): # n: Node Object if self._l == 0: self._h = n else: self._t.next = n self._t = n self._l += 1 def dequeue(self): if self._l == 0: print (\"Empty\") else: head = self._h if self._l == 1: self._t = None self._h = self._h.next self._l -= 1 return head def length(self): print (self._l) if __name__ == \"__main__\": import random queue = Queue() for i in range(10): num = random.randint(0, 9) + 1 print(num, end=' ') n = Node(num) queue.enqueue(n) print (\"length: \", queue.length()) for i in range(10): print (i+1, \":\", queue.dequeue().d)","categories":[{"name":"IT","slug":"IT","permalink":"https://rhkang.github.io/categories/IT/"},{"name":"Algorithm","slug":"IT/Algorithm","permalink":"https://rhkang.github.io/categories/IT/Algorithm/"}],"tags":[{"name":"Data Structure","slug":"Data-Structure","permalink":"https://rhkang.github.io/tags/Data-Structure/"},{"name":"Algorithm","slug":"Algorithm","permalink":"https://rhkang.github.io/tags/Algorithm/"}]},{"title":"[Hexo] 자주 쓰는 커맨드 & 알아두면 좋은 정보 모음(集)","slug":"hexo-information","date":"2018-05-09T04:09:20.000Z","updated":"2019-04-22T10:41:14.217Z","comments":true,"path":"2018/05/09/hexo-information/","link":"","permalink":"https://rhkang.github.io/2018/05/09/hexo-information/","excerpt":"","text":"Latest update: 2018.05.09 참고 링크 모음 https://highlightjs.org/static/demo/ - Syntax highlight reference https://shd101wyy.github.io/markdown-preview-enhanced/#/markdown-basics - Markdown 기본 문법 https://github.com/adam-p/markdown-here/wiki/Markdown-Cheatsheet#emphasis - Markdown Cheetsheet https://hexo.io/ko/docs/writing.html - Hexo basic usage http://futurecreator.github.io/2016/06/21/hexo-basic-usage/ - Hexo 기본 사용법 https://simhyejin.github.io/2016/06/24/hexo-themes/ - Hueman Theme 적용 Git 설정 (github 계정 연동) 12$ git config --global user.name &quot;user&quot;$ git config --global user.email &quot;mail address&quot; hexo 설치 1$ npm install -g hexo-cli 블로그 생성 123$ hexo init blog$ cd blog # move to directory$ npm install 포스트 생성부터 배포까지 1234567$ hexo new [layout] &quot;filename&quot;$ hexo clean$ hexo generate$ hexo server$ hexo deploy$ hexo publish [layout] &quot;title&quot; Line 1: ./source/_[layout]/filename.md 생성 (default: post) (post, page, draft)Line 2: Delete database and public folderLine 4: 로컬 서버 구동 http://localhost:4000/ (Option: –draft)Line 6: Draft(초안)을 Post로 publishing (제목 format에 맞춰 자동 수정, 생성 날짜 자동 추가) 포스트 이름에 대괄호를 포함할 경우 &quot; &quot;를 사용할 것 (안그럼 parsing error) Google Drive Image url//http://drive.google.com/open?export=view&amp;id=~ 를//http://drive.google.com/uc?export=view&amp;id=~ 로 변경 후 참조","categories":[{"name":"IT","slug":"IT","permalink":"https://rhkang.github.io/categories/IT/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://rhkang.github.io/tags/Hexo/"},{"name":"Markdown","slug":"Markdown","permalink":"https://rhkang.github.io/tags/Markdown/"}]},{"title":"네트워크 통신에서의 데이터 무결성 검사","slug":"about-checksum","date":"2018-05-08T04:53:33.000Z","updated":"2018-10-26T01:53:06.721Z","comments":true,"path":"2018/05/08/about-checksum/","link":"","permalink":"https://rhkang.github.io/2018/05/08/about-checksum/","excerpt":"","text":"네트워크 통신에서의 데이터 무결성 검사 … checksum INTRO누구나 컴퓨터는 0과 1로 이루어져 있다는 이야기를 들어본 적이 있을 것이다. 실제로 모든 디지털 정보는 0과 1의 조합을 통해 표현된다. 우리가 어떤 문자를 이용해 정보를 기록하는 것과 같은 이치로 볼 수 있는데, 그 이해를 위해 두 가지 간단한 예를 들어보겠다. 먼저, 사람이 사용하는 문장을 0과 1로 바꾸어보자. 만약 a부터 e까지 다섯 개의 알파벳을 a: 000 / b: 001 / c: 01 / d: 10 / e: 11 와 같이 대응시킨다면, ‘abbdca’라는 문장은 ‘0000010011001000’로, 거꾸로 ‘0000010011001000’라는 문장은 위 대응 관계에 근거하여 ‘abbdca’로 유일하게 해석됨을 직접 확인할 수 있다. 이번에는 어떤 명령들을 0과 1로 나타내보자. 4가지 명령 ‘앉아’, ‘일어서’, ‘왼손’, ‘오른손’을 최대한 짧은 길이의 문장으로 겹치지 않게 표현하기 위해선 최소 4가지의 경우를 나타낼 수 있는 0과 1의 조합을 생각해야한다. 이 경우에는 2-bit 만을 이용하여 00, 01, 10, 11 네 가지 경우를 각 명령에 대응 시킬 수 있으며, 해석하는 입장에서는 각 bit의 값을 보고 즉각 어떤 명령인지 알 수 있을 것이다. 우리가 매일 사용하는 전자기기들은 매 순간 이러한 문장들을 저장하고, 컴퓨터의 중추 CPU에서는 0과 1로 표현된 정해진 길이의 명령들을 1초에 수억번에서 수십억번 가까이 처리하고 있다. 특히 전자기기가 일반인들에게 널리 보급되고, 모든 분야에서 컴퓨터가 사용되고 있으며, 네트워크가 상상할 수 없는 규모로 확장된 지금 사회에선 매 순간 엄청난 양의 정보들이 이동하고 있다. 여기서 한 가지 의문이 든다. 0과 1로만 이루어진 정보를 무선 통신으로 주고 받는데, 우리의 스마트폰과 노트북은 지구 반대편에서 보낸 정보 조차 한치의 오차 없이 받아낸다. 데이터의 결함은 그 규모에 상관 없이 큰 골칫거리인게, 위에서 예로 든 ‘0000010011001000’를 전송하는 도중 통신의 장애로 인해 ‘0000000011001000’으로 받아진다면 그 의미는 ‘abbdca’가 아닌 ‘aabdca’로 완전히 다른 뜻이 되어버린다. 전송하는 문장이 어떤 명령이라면 시스템 자체에 결함이 생기는 것이다. 하지만 당장 비가 오는 날 축구 생중계를 볼 때만 해도 통신 상태가 불안정해 TV화면이 자주 끊기는데, 네트워크 통신에서는 어떻게 아무 결함 없이 데이터가 전송될까? 이를 해결하는 단순하지만 강력한 방법, 체크섬(checksum)을 소개하려고 한다. Checksum이란체크섬은 중복 검사의 한 형태로, 수신한 자료의 무결성을 보장하려는 하나의 시도라 할 수 있다. 그 형태는 전송하려는 데이터를 더하여 얻은 값에 정해진 비트 수의 모듈라 연산을 취함으로서 결정되는 bit-string이며, 발신하는 입장에서는 raw-data에 checksum을 이어붙여 만들어진 새로운 데이터를 전송한다. [~그림~] 위 그림을 보면 이해에 큰 도움이 될 것이다. Pre-code는 어떤 작업(실행)을 위해 필요한 필수 정보들이라 생각하면 되고, 실질적으로 해석해야 할 raw-data에 대해서 어떤 함수 f를 통해 생성되는 bit-string이 checksum이며, 이 파일의 꼬리에 checksum이 붙는 형태이다. Checksum의 동작크게 생성 함수 $f$에 대해서, 그리고 checksum을 통해 어떻게 무결성이 검증되는지 이 두 가지를 설명하려 한다. 방법만 보았을 땐 둘 다 굉장히 간단하다. Checksum의 생성흔히 나열된 데이터를 더하여 체크섬 숫자를 얻고, 이 숫자를 정해진 수로 나누어 그 나머지를 checksum으로 지정한다. 간단하게 예를 들어보겠다. 우리는 지금 32-bit(8-byte) 길이의 데이터에 대해 1-byte checksum을 생성하려고 한다. 32-bit data를 $m$이라 하고, 이 값은 $A267CBF3_{(16)}$이라 하자. 각 byte를 모두 더하면 $43_{(16)}$이 된다. 이때 checksum은 1-byte 크기이므로 $3_{(16)}$, 즉 $0011_{(2)}$이 될 것이다. 식으로 나타내면, $f(m) = c$ where $m = A267CBF3_{(16)}$, $c = 0011_{(2)}$ 무결성 검증수신한 메시지에서 raw-data와 checksum에 해당하는 bit-string을 각각 $m’$, $c’$이라 하자. 이때 checksum 생성 함수 $f$는 서로 약속되어 있다. 만약 $f(m’) = c’$이면, 메시지의 변조나 누락이 없다고 판단한다. 데이터의 변조는 크게 두 가지 케이스로 나뉜다. 전송 과정에서 발생하는 물리적인 장애로 인한 변조 의도적인 데이터 조작 여기까지 납득했다면 checksum은 1.의 대안으로 등장했다는 것을 알 수 있다. 2.의 경우 프로토콜의 암호화를 통해 극복한다. 이 이야기를 갑자기 한 이유는 단순하게 정의된 $f$에 대해 만들어진 $f(m’)$과 주어진 $c’$값의 비교 만으로 어떻게 무결성이 보장되는지 설명하기 위함이다. $m’$은 어떤 이유로 인해 $m$(송신 raw-data)의 bit들이 변조된 bit-string이고, $c’$도 마찬가지의 이유로 변조되었을 가능성이 존재한다. 이 때 checksum이 1-bit라면 $m=m’$이 아닌데도 $f(m’)=c’$ 이 될 확률이 굉장히 높을 수 있다. 하지만, checksum의 bit를 하나 늘려 2-bit checksum으로 만들어버리면, 그 확률이 크게 감소한다. 구체적으로는, checksum bit가 2배로 늘어날 때마다 ‘$m \\ne m’$이면서 $f(m’)=c’$일 확률’은 logarithmic하게 감소한다. Checksum 생성 함수 $f$의 특징을 고려하여 경우를 따져보면 쉽게 그 이유를 확인할 수 있는데, 글로만 보아선 크게 와닿지 않으므로 직접 간단한 테스트를 해보았다. [checksum : 2bit, trials=10000] [checksum : 4bit, trials=10000] [checksum : 8bit, trials=10000] [checksum : 16bit, trials=10000] Probability : 0.252 Probability : 0.0645 Probability : 0.004 Probability : 0.0 Probability : 0.2471 Probability : 0.0631 Probability : 0.0033 Probability : 0.0 Probability : 0.2506 Probability : 0.06 Probability : 0.004 Probability : 0.0 Probability : 0.2487 Probability : 0.0623 Probability : 0.0038 Probability : 0.0 Probability : 0.2489 Probability : 0.0677 Probability : 0.0036 Probability : 0.0001 Probability : 0.2487 Probability : 0.0624 Probability : 0.0042 Probability : 0.0 Probability : 0.2521 Probability : 0.0634 Probability : 0.0041 Probability : 0.0 Probability : 0.2491 Probability : 0.0641 Probability : 0.0031 Probability : 0.0 Probability : 0.255 Probability : 0.0625 Probability : 0.0035 Probability : 0.0 Probability : 0.247 Probability : 0.0655 Probability : 0.0034 Probability : 0.0 Average : 0.2499 Average : 0.0636 (0.2499^2 $\\simeq$ 0.06245) Average : 0.0037 (0.0636^2 $\\simeq$ 0.00404) Average : 0 0과 1로 이루어진 임의의 문장을 생성하고, 각 bit에 대해 동일하게 변조될 확률을 부여한다. 이를 통해 각 케이스 당 10번, 그리고 각 시도 당 10000번 $f(m’)=c’$여부를 확인하여 확률을 도출해냈다. Checksum bit를 2배로 늘려가며 같은 시행을 총 4번 반복하였고, 이를 통해 값들이 서로 지수적인 관계를 가진다는 것을 보이려했다. 2017학년도 1학기에 해보았던 것이라 구체적으로 설정했던 $m$의 length와 각 bit의 변조 확률은 기억나지 않는다. (아쉽게도 소스 코드를 폐기한듯..) 하지만 위 실험 결과로 미루어 보아 위에서 강조한 내용이 맞는 것을 확인할 수 있다..! 즉, 어떤 메시지를 수신한 후, 그에 해당하는 $m’$과 $c’$에 대해 $f(m’)=c’$이 아닐경우 이를 reject하고 다시 같은 요청을 보내는데, 변조된 메시지가 이 과정을 통과할 가능성은 checksum의 길이에 따라 급격히 줄어드는 것이다. 실제로 인터넷 통신 시스템이나 마이크로프로세서 시스템 내부 명령에서의 오류 검증에 checksum이 사용되며, 그 정확성은 확률로서 보장한다. 이런 간단한 방식으로 완전한 데이터 통신을 보장할 수 있다는 점이 실로 놀랍다! 관심있는 사람은 확률을 통해 정확성을 보장하는 비슷한 방식의 영지식 증명 프로토콜(ZKP)도 함께 살펴보면 좋을 것 같다.","categories":[{"name":"IT","slug":"IT","permalink":"https://rhkang.github.io/categories/IT/"}],"tags":[]}]}